"""
Marks the GraphQL type as indexable entity.  Each type that should be an entity is required to be annotated with this directive.
"""
directive @entity on OBJECT

"""Defined a Subgraph ID for an object type"""
directive @subgraphId(id: String!) on OBJECT

"""
creates a virtual field on the entity that may be queried but cannot be set manually through the mappings API.
"""
directive @derivedFrom(field: String!) on FIELD_DEFINITION

enum Aggregation_interval {
  hour
  day
}

"The BalancerWeightedPool entity contains the details of a BalancerWeightedPool Token.\n"
type BalancerWeightedPool {
  "Unique ID for the BalancerWeightedPool entity, in the format:\n[chain Id]_[pool address]\n"
  id: String!

  "The pool's vault address.\n"
  vaultAddress: String!

  "The pool's ID, for use in calls to vault functions.\n"
  poolId: String!

  "A list of the Tokens which make up the vault.\n"
  constituentTokens(skip: Int = 0, first: Int = 100, orderBy: Token_orderBy, orderDirection: OrderDirection, where: Token_filter): [Token!]!
}

input BalancerWeightedPool_filter {
  id: String
  id_not: String
  id_gt: String
  id_lt: String
  id_gte: String
  id_lte: String
  id_in: [String!]
  id_not_in: [String!]
  id_contains: String
  id_contains_nocase: String
  id_not_contains: String
  id_not_contains_nocase: String
  id_starts_with: String
  id_starts_with_nocase: String
  id_not_starts_with: String
  id_not_starts_with_nocase: String
  id_ends_with: String
  id_ends_with_nocase: String
  id_not_ends_with: String
  id_not_ends_with_nocase: String
  vaultAddress: String
  vaultAddress_not: String
  vaultAddress_gt: String
  vaultAddress_lt: String
  vaultAddress_gte: String
  vaultAddress_lte: String
  vaultAddress_in: [String!]
  vaultAddress_not_in: [String!]
  vaultAddress_contains: String
  vaultAddress_contains_nocase: String
  vaultAddress_not_contains: String
  vaultAddress_not_contains_nocase: String
  vaultAddress_starts_with: String
  vaultAddress_starts_with_nocase: String
  vaultAddress_not_starts_with: String
  vaultAddress_not_starts_with_nocase: String
  vaultAddress_ends_with: String
  vaultAddress_ends_with_nocase: String
  vaultAddress_not_ends_with: String
  vaultAddress_not_ends_with_nocase: String
  poolId: String
  poolId_not: String
  poolId_gt: String
  poolId_lt: String
  poolId_gte: String
  poolId_lte: String
  poolId_in: [String!]
  poolId_not_in: [String!]
  poolId_contains: String
  poolId_contains_nocase: String
  poolId_not_contains: String
  poolId_not_contains_nocase: String
  poolId_starts_with: String
  poolId_starts_with_nocase: String
  poolId_not_starts_with: String
  poolId_not_starts_with_nocase: String
  poolId_ends_with: String
  poolId_ends_with_nocase: String
  poolId_not_ends_with: String
  poolId_not_ends_with_nocase: String
  constituentTokens: [String!]
  constituentTokens_not: [String!]
  constituentTokens_contains: [String!]
  constituentTokens_contains_nocase: [String!]
  constituentTokens_not_contains: [String!]
  constituentTokens_not_contains_nocase: [String!]
  constituentTokens_: Token_filter

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [BalancerWeightedPool_filter]
  or: [BalancerWeightedPool_filter]
}

enum BalancerWeightedPool_orderBy {
  id
  vaultAddress
  poolId
  constituentTokens
}

scalar BigDecimal

scalar BigInt

input BlockChangedFilter {
  number_gte: Int!
}

input Block_height {
  hash: Bytes
  number: Int
  number_gte: Int
}

"The BondPurchase entity tracks individual bond purchases.\n"
type BondPurchase {
  "The transaction hash is used as the BondPurchase ID.\n"
  id: String!

  "The ID of the Market from which the bond was purchased.\n"
  market: Market!

  "The owner address of the Market from which the bond was purchased.\n"
  owner: String!

  "The amount of quote tokens paid.\n"
  amount: BigDecimal!

  "The amount of payout tokens purchased.\n"
  payout: BigDecimal!

  "The purchaser's address.\n"
  recipient: String!

  "The frontend referrer address.\n"
  referrer: String!

  "The time of the purchase.\n"
  timestamp: BigInt!

  "The address of the relevant Teller contract.\n"
  teller: String!

  "The address of the relevant Auctioneer contract.\n"
  auctioneer: String!

  "A reference to the payout Token record.\n"
  payoutToken: Token!

  "A reference to the quote Token record.\n"
  quoteToken: Token!

  "The network name, as used by Graph Protocol.\n**NOTE** This may not be the same as the name as used by wallets.\nAs such, we use the chainId field to identify networks in our frontend.\n"
  network: String!

  "The numeric chain ID on which the contracts are deployed.\n"
  chainId: BigInt!

  "The price at which the bond was purchased.\n**NOTE** this is quoteToken amount / payoutToken amount, it is NOT a USD price.\n"
  purchasePrice: BigDecimal!

  "The new bond price, updated after the purchase.\n**NOTE** this is the Auctioneer contract's marketPrice adjusted for marketScale, it is NOT a USD price.\n"
  postPurchasePrice: BigDecimal!

  "A reference to the OwnerTokenTbv record for this chain/owner/token combination.\n"
  ownerTokenTbv: OwnerTokenTbv

  "A reference to the PayoutTokenTbv record for this chain/owner/token combination.\n"
  payoutTokenTbv: PayoutTokenTbv
}

input BondPurchase_filter {
  id: String
  id_not: String
  id_gt: String
  id_lt: String
  id_gte: String
  id_lte: String
  id_in: [String!]
  id_not_in: [String!]
  id_contains: String
  id_contains_nocase: String
  id_not_contains: String
  id_not_contains_nocase: String
  id_starts_with: String
  id_starts_with_nocase: String
  id_not_starts_with: String
  id_not_starts_with_nocase: String
  id_ends_with: String
  id_ends_with_nocase: String
  id_not_ends_with: String
  id_not_ends_with_nocase: String
  market: String
  market_not: String
  market_gt: String
  market_lt: String
  market_gte: String
  market_lte: String
  market_in: [String!]
  market_not_in: [String!]
  market_contains: String
  market_contains_nocase: String
  market_not_contains: String
  market_not_contains_nocase: String
  market_starts_with: String
  market_starts_with_nocase: String
  market_not_starts_with: String
  market_not_starts_with_nocase: String
  market_ends_with: String
  market_ends_with_nocase: String
  market_not_ends_with: String
  market_not_ends_with_nocase: String
  market_: Market_filter
  owner: String
  owner_not: String
  owner_gt: String
  owner_lt: String
  owner_gte: String
  owner_lte: String
  owner_in: [String!]
  owner_not_in: [String!]
  owner_contains: String
  owner_contains_nocase: String
  owner_not_contains: String
  owner_not_contains_nocase: String
  owner_starts_with: String
  owner_starts_with_nocase: String
  owner_not_starts_with: String
  owner_not_starts_with_nocase: String
  owner_ends_with: String
  owner_ends_with_nocase: String
  owner_not_ends_with: String
  owner_not_ends_with_nocase: String
  amount: BigDecimal
  amount_not: BigDecimal
  amount_gt: BigDecimal
  amount_lt: BigDecimal
  amount_gte: BigDecimal
  amount_lte: BigDecimal
  amount_in: [BigDecimal!]
  amount_not_in: [BigDecimal!]
  payout: BigDecimal
  payout_not: BigDecimal
  payout_gt: BigDecimal
  payout_lt: BigDecimal
  payout_gte: BigDecimal
  payout_lte: BigDecimal
  payout_in: [BigDecimal!]
  payout_not_in: [BigDecimal!]
  recipient: String
  recipient_not: String
  recipient_gt: String
  recipient_lt: String
  recipient_gte: String
  recipient_lte: String
  recipient_in: [String!]
  recipient_not_in: [String!]
  recipient_contains: String
  recipient_contains_nocase: String
  recipient_not_contains: String
  recipient_not_contains_nocase: String
  recipient_starts_with: String
  recipient_starts_with_nocase: String
  recipient_not_starts_with: String
  recipient_not_starts_with_nocase: String
  recipient_ends_with: String
  recipient_ends_with_nocase: String
  recipient_not_ends_with: String
  recipient_not_ends_with_nocase: String
  referrer: String
  referrer_not: String
  referrer_gt: String
  referrer_lt: String
  referrer_gte: String
  referrer_lte: String
  referrer_in: [String!]
  referrer_not_in: [String!]
  referrer_contains: String
  referrer_contains_nocase: String
  referrer_not_contains: String
  referrer_not_contains_nocase: String
  referrer_starts_with: String
  referrer_starts_with_nocase: String
  referrer_not_starts_with: String
  referrer_not_starts_with_nocase: String
  referrer_ends_with: String
  referrer_ends_with_nocase: String
  referrer_not_ends_with: String
  referrer_not_ends_with_nocase: String
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  teller: String
  teller_not: String
  teller_gt: String
  teller_lt: String
  teller_gte: String
  teller_lte: String
  teller_in: [String!]
  teller_not_in: [String!]
  teller_contains: String
  teller_contains_nocase: String
  teller_not_contains: String
  teller_not_contains_nocase: String
  teller_starts_with: String
  teller_starts_with_nocase: String
  teller_not_starts_with: String
  teller_not_starts_with_nocase: String
  teller_ends_with: String
  teller_ends_with_nocase: String
  teller_not_ends_with: String
  teller_not_ends_with_nocase: String
  auctioneer: String
  auctioneer_not: String
  auctioneer_gt: String
  auctioneer_lt: String
  auctioneer_gte: String
  auctioneer_lte: String
  auctioneer_in: [String!]
  auctioneer_not_in: [String!]
  auctioneer_contains: String
  auctioneer_contains_nocase: String
  auctioneer_not_contains: String
  auctioneer_not_contains_nocase: String
  auctioneer_starts_with: String
  auctioneer_starts_with_nocase: String
  auctioneer_not_starts_with: String
  auctioneer_not_starts_with_nocase: String
  auctioneer_ends_with: String
  auctioneer_ends_with_nocase: String
  auctioneer_not_ends_with: String
  auctioneer_not_ends_with_nocase: String
  payoutToken: String
  payoutToken_not: String
  payoutToken_gt: String
  payoutToken_lt: String
  payoutToken_gte: String
  payoutToken_lte: String
  payoutToken_in: [String!]
  payoutToken_not_in: [String!]
  payoutToken_contains: String
  payoutToken_contains_nocase: String
  payoutToken_not_contains: String
  payoutToken_not_contains_nocase: String
  payoutToken_starts_with: String
  payoutToken_starts_with_nocase: String
  payoutToken_not_starts_with: String
  payoutToken_not_starts_with_nocase: String
  payoutToken_ends_with: String
  payoutToken_ends_with_nocase: String
  payoutToken_not_ends_with: String
  payoutToken_not_ends_with_nocase: String
  payoutToken_: Token_filter
  quoteToken: String
  quoteToken_not: String
  quoteToken_gt: String
  quoteToken_lt: String
  quoteToken_gte: String
  quoteToken_lte: String
  quoteToken_in: [String!]
  quoteToken_not_in: [String!]
  quoteToken_contains: String
  quoteToken_contains_nocase: String
  quoteToken_not_contains: String
  quoteToken_not_contains_nocase: String
  quoteToken_starts_with: String
  quoteToken_starts_with_nocase: String
  quoteToken_not_starts_with: String
  quoteToken_not_starts_with_nocase: String
  quoteToken_ends_with: String
  quoteToken_ends_with_nocase: String
  quoteToken_not_ends_with: String
  quoteToken_not_ends_with_nocase: String
  quoteToken_: Token_filter
  network: String
  network_not: String
  network_gt: String
  network_lt: String
  network_gte: String
  network_lte: String
  network_in: [String!]
  network_not_in: [String!]
  network_contains: String
  network_contains_nocase: String
  network_not_contains: String
  network_not_contains_nocase: String
  network_starts_with: String
  network_starts_with_nocase: String
  network_not_starts_with: String
  network_not_starts_with_nocase: String
  network_ends_with: String
  network_ends_with_nocase: String
  network_not_ends_with: String
  network_not_ends_with_nocase: String
  chainId: BigInt
  chainId_not: BigInt
  chainId_gt: BigInt
  chainId_lt: BigInt
  chainId_gte: BigInt
  chainId_lte: BigInt
  chainId_in: [BigInt!]
  chainId_not_in: [BigInt!]
  purchasePrice: BigDecimal
  purchasePrice_not: BigDecimal
  purchasePrice_gt: BigDecimal
  purchasePrice_lt: BigDecimal
  purchasePrice_gte: BigDecimal
  purchasePrice_lte: BigDecimal
  purchasePrice_in: [BigDecimal!]
  purchasePrice_not_in: [BigDecimal!]
  postPurchasePrice: BigDecimal
  postPurchasePrice_not: BigDecimal
  postPurchasePrice_gt: BigDecimal
  postPurchasePrice_lt: BigDecimal
  postPurchasePrice_gte: BigDecimal
  postPurchasePrice_lte: BigDecimal
  postPurchasePrice_in: [BigDecimal!]
  postPurchasePrice_not_in: [BigDecimal!]
  ownerTokenTbv: String
  ownerTokenTbv_not: String
  ownerTokenTbv_gt: String
  ownerTokenTbv_lt: String
  ownerTokenTbv_gte: String
  ownerTokenTbv_lte: String
  ownerTokenTbv_in: [String!]
  ownerTokenTbv_not_in: [String!]
  ownerTokenTbv_contains: String
  ownerTokenTbv_contains_nocase: String
  ownerTokenTbv_not_contains: String
  ownerTokenTbv_not_contains_nocase: String
  ownerTokenTbv_starts_with: String
  ownerTokenTbv_starts_with_nocase: String
  ownerTokenTbv_not_starts_with: String
  ownerTokenTbv_not_starts_with_nocase: String
  ownerTokenTbv_ends_with: String
  ownerTokenTbv_ends_with_nocase: String
  ownerTokenTbv_not_ends_with: String
  ownerTokenTbv_not_ends_with_nocase: String
  ownerTokenTbv_: OwnerTokenTbv_filter
  payoutTokenTbv: String
  payoutTokenTbv_not: String
  payoutTokenTbv_gt: String
  payoutTokenTbv_lt: String
  payoutTokenTbv_gte: String
  payoutTokenTbv_lte: String
  payoutTokenTbv_in: [String!]
  payoutTokenTbv_not_in: [String!]
  payoutTokenTbv_contains: String
  payoutTokenTbv_contains_nocase: String
  payoutTokenTbv_not_contains: String
  payoutTokenTbv_not_contains_nocase: String
  payoutTokenTbv_starts_with: String
  payoutTokenTbv_starts_with_nocase: String
  payoutTokenTbv_not_starts_with: String
  payoutTokenTbv_not_starts_with_nocase: String
  payoutTokenTbv_ends_with: String
  payoutTokenTbv_ends_with_nocase: String
  payoutTokenTbv_not_ends_with: String
  payoutTokenTbv_not_ends_with_nocase: String
  payoutTokenTbv_: PayoutTokenTbv_filter

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [BondPurchase_filter]
  or: [BondPurchase_filter]
}

enum BondPurchase_orderBy {
  id
  market
  market__id
  market__name
  market__type
  market__network
  market__chainId
  market__auctioneer
  market__teller
  market__marketId
  market__owner
  market__vesting
  market__start
  market__conclusion
  market__vestingType
  market__isInstantSwap
  market__hasClosed
  market__totalBondedAmount
  market__totalPayoutAmount
  market__creationBlockTimestamp
  market__callbackAddress
  market__capacity
  market__capacityInQuote
  market__minPrice
  market__price
  market__scale
  market__averageBondPrice
  market__bondsIssued
  owner
  amount
  payout
  recipient
  referrer
  timestamp
  teller
  auctioneer
  payoutToken
  payoutToken__id
  payoutToken__network
  payoutToken__chainId
  payoutToken__address
  payoutToken__decimals
  payoutToken__symbol
  payoutToken__name
  payoutToken__typeName
  payoutToken__usedAsPayout
  payoutToken__usedAsQuote
  payoutToken__totalPayoutAmount
  payoutToken__purchaseCount
  quoteToken
  quoteToken__id
  quoteToken__network
  quoteToken__chainId
  quoteToken__address
  quoteToken__decimals
  quoteToken__symbol
  quoteToken__name
  quoteToken__typeName
  quoteToken__usedAsPayout
  quoteToken__usedAsQuote
  quoteToken__totalPayoutAmount
  quoteToken__purchaseCount
  network
  chainId
  purchasePrice
  postPurchasePrice
  ownerTokenTbv
  ownerTokenTbv__id
  ownerTokenTbv__owner
  ownerTokenTbv__token
  ownerTokenTbv__network
  ownerTokenTbv__chainId
  ownerTokenTbv__tbv
  payoutTokenTbv
  payoutTokenTbv__id
  payoutTokenTbv__network
  payoutTokenTbv__chainId
  payoutTokenTbv__tbv
}

"A BondToken record is created to track vesting tokens, both ERC-20 and ERC-1155, created by our contracts.\n"
type BondToken {
  "Unique ID for the BondToken entity. In the case of an ERC-20 token, this will be the token's address. In the case of an ERC-1155 token, it will be the token's ID.\n"
  id: String!

  "The number of decimals if an ERC-20, null if an ERC-1155.\n"
  decimals: BigInt

  "The token symbol if an ERC-20, null if an ERC-1155.\n"
  symbol: String

  "A reference to the Token which will be paid out upon vesting.\n"
  underlying: Token!

  "Timestamp at which vesting completes.\n"
  expiry: BigInt!

  "The address of the relevant Teller contract.\n"
  teller: String!

  "The network name, as used by Graph Protocol.\n**NOTE** This may not be the same as the name as used by wallets.\nAs such, we use the chainId field to identify networks in our frontend.\n"
  network: String!

  "The numeric chain ID on which the contracts are deployed.\n"
  chainId: BigInt!

  "The type of bond, either \"fixed-term\" or \"fixed-expiration\".\n"
  type: String!
}

input BondToken_filter {
  id: String
  id_not: String
  id_gt: String
  id_lt: String
  id_gte: String
  id_lte: String
  id_in: [String!]
  id_not_in: [String!]
  id_contains: String
  id_contains_nocase: String
  id_not_contains: String
  id_not_contains_nocase: String
  id_starts_with: String
  id_starts_with_nocase: String
  id_not_starts_with: String
  id_not_starts_with_nocase: String
  id_ends_with: String
  id_ends_with_nocase: String
  id_not_ends_with: String
  id_not_ends_with_nocase: String
  decimals: BigInt
  decimals_not: BigInt
  decimals_gt: BigInt
  decimals_lt: BigInt
  decimals_gte: BigInt
  decimals_lte: BigInt
  decimals_in: [BigInt!]
  decimals_not_in: [BigInt!]
  symbol: String
  symbol_not: String
  symbol_gt: String
  symbol_lt: String
  symbol_gte: String
  symbol_lte: String
  symbol_in: [String!]
  symbol_not_in: [String!]
  symbol_contains: String
  symbol_contains_nocase: String
  symbol_not_contains: String
  symbol_not_contains_nocase: String
  symbol_starts_with: String
  symbol_starts_with_nocase: String
  symbol_not_starts_with: String
  symbol_not_starts_with_nocase: String
  symbol_ends_with: String
  symbol_ends_with_nocase: String
  symbol_not_ends_with: String
  symbol_not_ends_with_nocase: String
  underlying: String
  underlying_not: String
  underlying_gt: String
  underlying_lt: String
  underlying_gte: String
  underlying_lte: String
  underlying_in: [String!]
  underlying_not_in: [String!]
  underlying_contains: String
  underlying_contains_nocase: String
  underlying_not_contains: String
  underlying_not_contains_nocase: String
  underlying_starts_with: String
  underlying_starts_with_nocase: String
  underlying_not_starts_with: String
  underlying_not_starts_with_nocase: String
  underlying_ends_with: String
  underlying_ends_with_nocase: String
  underlying_not_ends_with: String
  underlying_not_ends_with_nocase: String
  underlying_: Token_filter
  expiry: BigInt
  expiry_not: BigInt
  expiry_gt: BigInt
  expiry_lt: BigInt
  expiry_gte: BigInt
  expiry_lte: BigInt
  expiry_in: [BigInt!]
  expiry_not_in: [BigInt!]
  teller: String
  teller_not: String
  teller_gt: String
  teller_lt: String
  teller_gte: String
  teller_lte: String
  teller_in: [String!]
  teller_not_in: [String!]
  teller_contains: String
  teller_contains_nocase: String
  teller_not_contains: String
  teller_not_contains_nocase: String
  teller_starts_with: String
  teller_starts_with_nocase: String
  teller_not_starts_with: String
  teller_not_starts_with_nocase: String
  teller_ends_with: String
  teller_ends_with_nocase: String
  teller_not_ends_with: String
  teller_not_ends_with_nocase: String
  network: String
  network_not: String
  network_gt: String
  network_lt: String
  network_gte: String
  network_lte: String
  network_in: [String!]
  network_not_in: [String!]
  network_contains: String
  network_contains_nocase: String
  network_not_contains: String
  network_not_contains_nocase: String
  network_starts_with: String
  network_starts_with_nocase: String
  network_not_starts_with: String
  network_not_starts_with_nocase: String
  network_ends_with: String
  network_ends_with_nocase: String
  network_not_ends_with: String
  network_not_ends_with_nocase: String
  chainId: BigInt
  chainId_not: BigInt
  chainId_gt: BigInt
  chainId_lt: BigInt
  chainId_gte: BigInt
  chainId_lte: BigInt
  chainId_in: [BigInt!]
  chainId_not_in: [BigInt!]
  type: String
  type_not: String
  type_gt: String
  type_lt: String
  type_gte: String
  type_lte: String
  type_in: [String!]
  type_not_in: [String!]
  type_contains: String
  type_contains_nocase: String
  type_not_contains: String
  type_not_contains_nocase: String
  type_starts_with: String
  type_starts_with_nocase: String
  type_not_starts_with: String
  type_not_starts_with_nocase: String
  type_ends_with: String
  type_ends_with_nocase: String
  type_not_ends_with: String
  type_not_ends_with_nocase: String

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [BondToken_filter]
  or: [BondToken_filter]
}

enum BondToken_orderBy {
  id
  decimals
  symbol
  underlying
  underlying__id
  underlying__network
  underlying__chainId
  underlying__address
  underlying__decimals
  underlying__symbol
  underlying__name
  underlying__typeName
  underlying__usedAsPayout
  underlying__usedAsQuote
  underlying__totalPayoutAmount
  underlying__purchaseCount
  expiry
  teller
  network
  chainId
  type
}

scalar Bytes

"8 bytes signed integer\n"
scalar Int8

"The Market entity tracks all bond markets which have been created, whether currently open or closed.\n"
type Market {
  "Unique ID for the Market entity, in the format:\n[chainId]_[auctioneer contract name]_[market id]\n**NOTE** At the time of writing, contract name will be either 'BondFixedTermCDA' or BondFixedExpCDA. More will be added in the future as different auctioneer types become available.\n"
  id: String!

  "The Auctioneer contract name.\n"
  name: String!

  "The type of Market.\n"
  type: String!

  "The network name, as used by Graph Protocol.\n**NOTE** This may not be the same as the name as used by wallets.\nAs such, we use the chainId field to identify networks in our frontend.\n"
  network: String!

  "The numeric chain ID on which the contracts are deployed.\n"
  chainId: BigInt!

  "The address of the Market's Auctioneer contract.\n"
  auctioneer: String!

  "The address of the Market's Teller contract.\n"
  teller: String!

  "The Market's ID for use with the Auctioneer.\n"
  marketId: BigInt!

  "The address of the Market owner.\n"
  owner: String!

  "A reference to the payout Token record.\n"
  payoutToken: Token!

  "A reference to the quote Token record.\n"
  quoteToken: Token!

  "The Market's vesting time. In the case of fixed expiry markets, this will be a timestamp. In the case of fixed term markets, it will be the vesting duration in seconds.\n"
  vesting: BigInt!

  "The Market's start time (for supported Market types)\n"
  start: BigInt

  "The Market's conclusion time\n"
  conclusion: BigInt

  "The type of vesting for the market. At the time of writing, this will be either \"fixed-term\" or \"fixed-expiration\". More options may be added in the future if new vesting types become available.\n"
  vestingType: String!

  "Whether or not the Market is an instant swap market.\n"
  isInstantSwap: Boolean!

  "Whether or not the Market has been closed.\n"
  hasClosed: Boolean!

  "The total amount of quote tokens bonded for this market.\n**NOTE** This is the number of quote tokens, NOT their USD value.\n"
  totalBondedAmount: BigDecimal!

  "The total amount of payout tokens purchased through this market.\n**NOTE** This is the number of payout tokens, NOT their USD value.\n"
  totalPayoutAmount: BigDecimal!

  "The timestamp of the block in which the Market was created.\n"
  creationBlockTimestamp: BigInt!

  "The address of the Market callback contract, if specified. 0x0000000000000000000000000000000000000000 if there is no callback contract.\n"
  callbackAddress: String!

  "The current capacity of the Market. This can be in either the quote or payout Token, according to the value of the capacityInQuote field.\n"
  capacity: BigInt!

  "Whether the Market capacity is measured in the quote (true) or payout (false) Token.\n"
  capacityInQuote: Boolean!

  "The minimum price at which a bond can be purchased.\n**NOTE** This is a minimum return value for the Auctioneer marketPrice function, NOT a USD price.\n"
  minPrice: BigInt

  "The price at which a bond can be purchased.\n**NOTE** This is a minimum return value for the Auctioneer marketPrice function, NOT a USD price.\n"
  price: BigInt

  "Scale value to use when converting between quote token and payout token amounts with marketPrice.\n"
  scale: BigInt

  "The average bond price across all purchases.\n"
  averageBondPrice: BigDecimal

  "A list of all tuning events that have been emitted for this Market.\n"
  tunes(skip: Int = 0, first: Int = 100, orderBy: Tune_orderBy, orderDirection: OrderDirection, where: Tune_filter): [Tune!]

  "A list of BondPurchase records for this Market.\n"
  bondPurchases(skip: Int = 0, first: Int = 100, orderBy: BondPurchase_orderBy, orderDirection: OrderDirection, where: BondPurchase_filter): [BondPurchase!]

  "A count of BondPurchases for this market\n"
  bondsIssued: BigInt!
}

"Workaround due to no simple entity count being available.\n"
type MarketOwnerCount {
  "There should be one MarketOwnerCount entry per market owner, with owner address as id.\n"
  id: String!

  "The total number of markets (open and closed) owned by this address on this chain.\n"
  count: BigInt!
}

input MarketOwnerCount_filter {
  id: String
  id_not: String
  id_gt: String
  id_lt: String
  id_gte: String
  id_lte: String
  id_in: [String!]
  id_not_in: [String!]
  id_contains: String
  id_contains_nocase: String
  id_not_contains: String
  id_not_contains_nocase: String
  id_starts_with: String
  id_starts_with_nocase: String
  id_not_starts_with: String
  id_not_starts_with_nocase: String
  id_ends_with: String
  id_ends_with_nocase: String
  id_not_ends_with: String
  id_not_ends_with_nocase: String
  count: BigInt
  count_not: BigInt
  count_gt: BigInt
  count_lt: BigInt
  count_gte: BigInt
  count_lte: BigInt
  count_in: [BigInt!]
  count_not_in: [BigInt!]

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [MarketOwnerCount_filter]
  or: [MarketOwnerCount_filter]
}

enum MarketOwnerCount_orderBy {
  id
  count
}

input Market_filter {
  id: String
  id_not: String
  id_gt: String
  id_lt: String
  id_gte: String
  id_lte: String
  id_in: [String!]
  id_not_in: [String!]
  id_contains: String
  id_contains_nocase: String
  id_not_contains: String
  id_not_contains_nocase: String
  id_starts_with: String
  id_starts_with_nocase: String
  id_not_starts_with: String
  id_not_starts_with_nocase: String
  id_ends_with: String
  id_ends_with_nocase: String
  id_not_ends_with: String
  id_not_ends_with_nocase: String
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  type: String
  type_not: String
  type_gt: String
  type_lt: String
  type_gte: String
  type_lte: String
  type_in: [String!]
  type_not_in: [String!]
  type_contains: String
  type_contains_nocase: String
  type_not_contains: String
  type_not_contains_nocase: String
  type_starts_with: String
  type_starts_with_nocase: String
  type_not_starts_with: String
  type_not_starts_with_nocase: String
  type_ends_with: String
  type_ends_with_nocase: String
  type_not_ends_with: String
  type_not_ends_with_nocase: String
  network: String
  network_not: String
  network_gt: String
  network_lt: String
  network_gte: String
  network_lte: String
  network_in: [String!]
  network_not_in: [String!]
  network_contains: String
  network_contains_nocase: String
  network_not_contains: String
  network_not_contains_nocase: String
  network_starts_with: String
  network_starts_with_nocase: String
  network_not_starts_with: String
  network_not_starts_with_nocase: String
  network_ends_with: String
  network_ends_with_nocase: String
  network_not_ends_with: String
  network_not_ends_with_nocase: String
  chainId: BigInt
  chainId_not: BigInt
  chainId_gt: BigInt
  chainId_lt: BigInt
  chainId_gte: BigInt
  chainId_lte: BigInt
  chainId_in: [BigInt!]
  chainId_not_in: [BigInt!]
  auctioneer: String
  auctioneer_not: String
  auctioneer_gt: String
  auctioneer_lt: String
  auctioneer_gte: String
  auctioneer_lte: String
  auctioneer_in: [String!]
  auctioneer_not_in: [String!]
  auctioneer_contains: String
  auctioneer_contains_nocase: String
  auctioneer_not_contains: String
  auctioneer_not_contains_nocase: String
  auctioneer_starts_with: String
  auctioneer_starts_with_nocase: String
  auctioneer_not_starts_with: String
  auctioneer_not_starts_with_nocase: String
  auctioneer_ends_with: String
  auctioneer_ends_with_nocase: String
  auctioneer_not_ends_with: String
  auctioneer_not_ends_with_nocase: String
  teller: String
  teller_not: String
  teller_gt: String
  teller_lt: String
  teller_gte: String
  teller_lte: String
  teller_in: [String!]
  teller_not_in: [String!]
  teller_contains: String
  teller_contains_nocase: String
  teller_not_contains: String
  teller_not_contains_nocase: String
  teller_starts_with: String
  teller_starts_with_nocase: String
  teller_not_starts_with: String
  teller_not_starts_with_nocase: String
  teller_ends_with: String
  teller_ends_with_nocase: String
  teller_not_ends_with: String
  teller_not_ends_with_nocase: String
  marketId: BigInt
  marketId_not: BigInt
  marketId_gt: BigInt
  marketId_lt: BigInt
  marketId_gte: BigInt
  marketId_lte: BigInt
  marketId_in: [BigInt!]
  marketId_not_in: [BigInt!]
  owner: String
  owner_not: String
  owner_gt: String
  owner_lt: String
  owner_gte: String
  owner_lte: String
  owner_in: [String!]
  owner_not_in: [String!]
  owner_contains: String
  owner_contains_nocase: String
  owner_not_contains: String
  owner_not_contains_nocase: String
  owner_starts_with: String
  owner_starts_with_nocase: String
  owner_not_starts_with: String
  owner_not_starts_with_nocase: String
  owner_ends_with: String
  owner_ends_with_nocase: String
  owner_not_ends_with: String
  owner_not_ends_with_nocase: String
  payoutToken: String
  payoutToken_not: String
  payoutToken_gt: String
  payoutToken_lt: String
  payoutToken_gte: String
  payoutToken_lte: String
  payoutToken_in: [String!]
  payoutToken_not_in: [String!]
  payoutToken_contains: String
  payoutToken_contains_nocase: String
  payoutToken_not_contains: String
  payoutToken_not_contains_nocase: String
  payoutToken_starts_with: String
  payoutToken_starts_with_nocase: String
  payoutToken_not_starts_with: String
  payoutToken_not_starts_with_nocase: String
  payoutToken_ends_with: String
  payoutToken_ends_with_nocase: String
  payoutToken_not_ends_with: String
  payoutToken_not_ends_with_nocase: String
  payoutToken_: Token_filter
  quoteToken: String
  quoteToken_not: String
  quoteToken_gt: String
  quoteToken_lt: String
  quoteToken_gte: String
  quoteToken_lte: String
  quoteToken_in: [String!]
  quoteToken_not_in: [String!]
  quoteToken_contains: String
  quoteToken_contains_nocase: String
  quoteToken_not_contains: String
  quoteToken_not_contains_nocase: String
  quoteToken_starts_with: String
  quoteToken_starts_with_nocase: String
  quoteToken_not_starts_with: String
  quoteToken_not_starts_with_nocase: String
  quoteToken_ends_with: String
  quoteToken_ends_with_nocase: String
  quoteToken_not_ends_with: String
  quoteToken_not_ends_with_nocase: String
  quoteToken_: Token_filter
  vesting: BigInt
  vesting_not: BigInt
  vesting_gt: BigInt
  vesting_lt: BigInt
  vesting_gte: BigInt
  vesting_lte: BigInt
  vesting_in: [BigInt!]
  vesting_not_in: [BigInt!]
  start: BigInt
  start_not: BigInt
  start_gt: BigInt
  start_lt: BigInt
  start_gte: BigInt
  start_lte: BigInt
  start_in: [BigInt!]
  start_not_in: [BigInt!]
  conclusion: BigInt
  conclusion_not: BigInt
  conclusion_gt: BigInt
  conclusion_lt: BigInt
  conclusion_gte: BigInt
  conclusion_lte: BigInt
  conclusion_in: [BigInt!]
  conclusion_not_in: [BigInt!]
  vestingType: String
  vestingType_not: String
  vestingType_gt: String
  vestingType_lt: String
  vestingType_gte: String
  vestingType_lte: String
  vestingType_in: [String!]
  vestingType_not_in: [String!]
  vestingType_contains: String
  vestingType_contains_nocase: String
  vestingType_not_contains: String
  vestingType_not_contains_nocase: String
  vestingType_starts_with: String
  vestingType_starts_with_nocase: String
  vestingType_not_starts_with: String
  vestingType_not_starts_with_nocase: String
  vestingType_ends_with: String
  vestingType_ends_with_nocase: String
  vestingType_not_ends_with: String
  vestingType_not_ends_with_nocase: String
  isInstantSwap: Boolean
  isInstantSwap_not: Boolean
  isInstantSwap_in: [Boolean!]
  isInstantSwap_not_in: [Boolean!]
  hasClosed: Boolean
  hasClosed_not: Boolean
  hasClosed_in: [Boolean!]
  hasClosed_not_in: [Boolean!]
  totalBondedAmount: BigDecimal
  totalBondedAmount_not: BigDecimal
  totalBondedAmount_gt: BigDecimal
  totalBondedAmount_lt: BigDecimal
  totalBondedAmount_gte: BigDecimal
  totalBondedAmount_lte: BigDecimal
  totalBondedAmount_in: [BigDecimal!]
  totalBondedAmount_not_in: [BigDecimal!]
  totalPayoutAmount: BigDecimal
  totalPayoutAmount_not: BigDecimal
  totalPayoutAmount_gt: BigDecimal
  totalPayoutAmount_lt: BigDecimal
  totalPayoutAmount_gte: BigDecimal
  totalPayoutAmount_lte: BigDecimal
  totalPayoutAmount_in: [BigDecimal!]
  totalPayoutAmount_not_in: [BigDecimal!]
  creationBlockTimestamp: BigInt
  creationBlockTimestamp_not: BigInt
  creationBlockTimestamp_gt: BigInt
  creationBlockTimestamp_lt: BigInt
  creationBlockTimestamp_gte: BigInt
  creationBlockTimestamp_lte: BigInt
  creationBlockTimestamp_in: [BigInt!]
  creationBlockTimestamp_not_in: [BigInt!]
  callbackAddress: String
  callbackAddress_not: String
  callbackAddress_gt: String
  callbackAddress_lt: String
  callbackAddress_gte: String
  callbackAddress_lte: String
  callbackAddress_in: [String!]
  callbackAddress_not_in: [String!]
  callbackAddress_contains: String
  callbackAddress_contains_nocase: String
  callbackAddress_not_contains: String
  callbackAddress_not_contains_nocase: String
  callbackAddress_starts_with: String
  callbackAddress_starts_with_nocase: String
  callbackAddress_not_starts_with: String
  callbackAddress_not_starts_with_nocase: String
  callbackAddress_ends_with: String
  callbackAddress_ends_with_nocase: String
  callbackAddress_not_ends_with: String
  callbackAddress_not_ends_with_nocase: String
  capacity: BigInt
  capacity_not: BigInt
  capacity_gt: BigInt
  capacity_lt: BigInt
  capacity_gte: BigInt
  capacity_lte: BigInt
  capacity_in: [BigInt!]
  capacity_not_in: [BigInt!]
  capacityInQuote: Boolean
  capacityInQuote_not: Boolean
  capacityInQuote_in: [Boolean!]
  capacityInQuote_not_in: [Boolean!]
  minPrice: BigInt
  minPrice_not: BigInt
  minPrice_gt: BigInt
  minPrice_lt: BigInt
  minPrice_gte: BigInt
  minPrice_lte: BigInt
  minPrice_in: [BigInt!]
  minPrice_not_in: [BigInt!]
  price: BigInt
  price_not: BigInt
  price_gt: BigInt
  price_lt: BigInt
  price_gte: BigInt
  price_lte: BigInt
  price_in: [BigInt!]
  price_not_in: [BigInt!]
  scale: BigInt
  scale_not: BigInt
  scale_gt: BigInt
  scale_lt: BigInt
  scale_gte: BigInt
  scale_lte: BigInt
  scale_in: [BigInt!]
  scale_not_in: [BigInt!]
  averageBondPrice: BigDecimal
  averageBondPrice_not: BigDecimal
  averageBondPrice_gt: BigDecimal
  averageBondPrice_lt: BigDecimal
  averageBondPrice_gte: BigDecimal
  averageBondPrice_lte: BigDecimal
  averageBondPrice_in: [BigDecimal!]
  averageBondPrice_not_in: [BigDecimal!]
  tunes_: Tune_filter
  bondPurchases_: BondPurchase_filter
  bondsIssued: BigInt
  bondsIssued_not: BigInt
  bondsIssued_gt: BigInt
  bondsIssued_lt: BigInt
  bondsIssued_gte: BigInt
  bondsIssued_lte: BigInt
  bondsIssued_in: [BigInt!]
  bondsIssued_not_in: [BigInt!]

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [Market_filter]
  or: [Market_filter]
}

enum Market_orderBy {
  id
  name
  type
  network
  chainId
  auctioneer
  teller
  marketId
  owner
  payoutToken
  payoutToken__id
  payoutToken__network
  payoutToken__chainId
  payoutToken__address
  payoutToken__decimals
  payoutToken__symbol
  payoutToken__name
  payoutToken__typeName
  payoutToken__usedAsPayout
  payoutToken__usedAsQuote
  payoutToken__totalPayoutAmount
  payoutToken__purchaseCount
  quoteToken
  quoteToken__id
  quoteToken__network
  quoteToken__chainId
  quoteToken__address
  quoteToken__decimals
  quoteToken__symbol
  quoteToken__name
  quoteToken__typeName
  quoteToken__usedAsPayout
  quoteToken__usedAsQuote
  quoteToken__totalPayoutAmount
  quoteToken__purchaseCount
  vesting
  start
  conclusion
  vestingType
  isInstantSwap
  hasClosed
  totalBondedAmount
  totalPayoutAmount
  creationBlockTimestamp
  callbackAddress
  capacity
  capacityInQuote
  minPrice
  price
  scale
  averageBondPrice
  tunes
  bondPurchases
  bondsIssued
}

"""Defines the order direction, either ascending or descending"""
enum OrderDirection {
  asc
  desc
}

"The OwnerBalance entity tracks user balances of fixed-term ERC-1155 bond tokens.\nIt does not track balances of fixed-expiry ERC-20 tokens. These can be found by querying the user's wallet.\n"
type OwnerBalance {
  "Unique ID for the OwnerBalance entity, in the format:\n[owner address]_[BondToken tokenId]\n"
  id: String!

  "The unique ID of the token, assigned on creation.\n"
  tokenId: BigInt!

  "The wallet address the balance pertains to.\n"
  owner: String!

  "The current balance of ERC-1155 bond tokens.\n"
  balance: BigInt!

  "The network name, as used by Graph Protocol.\n**NOTE** This may not be the same as the name as used by wallets.\nAs such, we use the chainId field to identify networks in our frontend.\n"
  network: String!

  "The numeric chain ID on which the contracts are deployed.\n"
  chainId: BigInt!

  "A reference to the BondToken for which the balance is being recorded.\n"
  bondToken: BondToken
}

input OwnerBalance_filter {
  id: String
  id_not: String
  id_gt: String
  id_lt: String
  id_gte: String
  id_lte: String
  id_in: [String!]
  id_not_in: [String!]
  id_contains: String
  id_contains_nocase: String
  id_not_contains: String
  id_not_contains_nocase: String
  id_starts_with: String
  id_starts_with_nocase: String
  id_not_starts_with: String
  id_not_starts_with_nocase: String
  id_ends_with: String
  id_ends_with_nocase: String
  id_not_ends_with: String
  id_not_ends_with_nocase: String
  tokenId: BigInt
  tokenId_not: BigInt
  tokenId_gt: BigInt
  tokenId_lt: BigInt
  tokenId_gte: BigInt
  tokenId_lte: BigInt
  tokenId_in: [BigInt!]
  tokenId_not_in: [BigInt!]
  owner: String
  owner_not: String
  owner_gt: String
  owner_lt: String
  owner_gte: String
  owner_lte: String
  owner_in: [String!]
  owner_not_in: [String!]
  owner_contains: String
  owner_contains_nocase: String
  owner_not_contains: String
  owner_not_contains_nocase: String
  owner_starts_with: String
  owner_starts_with_nocase: String
  owner_not_starts_with: String
  owner_not_starts_with_nocase: String
  owner_ends_with: String
  owner_ends_with_nocase: String
  owner_not_ends_with: String
  owner_not_ends_with_nocase: String
  balance: BigInt
  balance_not: BigInt
  balance_gt: BigInt
  balance_lt: BigInt
  balance_gte: BigInt
  balance_lte: BigInt
  balance_in: [BigInt!]
  balance_not_in: [BigInt!]
  network: String
  network_not: String
  network_gt: String
  network_lt: String
  network_gte: String
  network_lte: String
  network_in: [String!]
  network_not_in: [String!]
  network_contains: String
  network_contains_nocase: String
  network_not_contains: String
  network_not_contains_nocase: String
  network_starts_with: String
  network_starts_with_nocase: String
  network_not_starts_with: String
  network_not_starts_with_nocase: String
  network_ends_with: String
  network_ends_with_nocase: String
  network_not_ends_with: String
  network_not_ends_with_nocase: String
  chainId: BigInt
  chainId_not: BigInt
  chainId_gt: BigInt
  chainId_lt: BigInt
  chainId_gte: BigInt
  chainId_lte: BigInt
  chainId_in: [BigInt!]
  chainId_not_in: [BigInt!]
  bondToken: String
  bondToken_not: String
  bondToken_gt: String
  bondToken_lt: String
  bondToken_gte: String
  bondToken_lte: String
  bondToken_in: [String!]
  bondToken_not_in: [String!]
  bondToken_contains: String
  bondToken_contains_nocase: String
  bondToken_not_contains: String
  bondToken_not_contains_nocase: String
  bondToken_starts_with: String
  bondToken_starts_with_nocase: String
  bondToken_not_starts_with: String
  bondToken_not_starts_with_nocase: String
  bondToken_ends_with: String
  bondToken_ends_with_nocase: String
  bondToken_not_ends_with: String
  bondToken_not_ends_with_nocase: String
  bondToken_: BondToken_filter

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [OwnerBalance_filter]
  or: [OwnerBalance_filter]
}

enum OwnerBalance_orderBy {
  id
  tokenId
  owner
  balance
  network
  chainId
  bondToken
  bondToken__id
  bondToken__decimals
  bondToken__symbol
  bondToken__expiry
  bondToken__teller
  bondToken__network
  bondToken__chainId
  bondToken__type
}

"The OwnerTokenTbv entity tracks the total of each quote token received by each Market owner.\n"
type OwnerTokenTbv {
  "Unique ID for the OwnerTokenTbv entity, in the format:\n[chainId]_[Market owner address]__[quote Token id]\n**NOTE** the Token ID also appends the chain ID before the token address, so the chain ID will appear once at the start of the OwnerTokenTbv ID and once in the quote token subsection of the ID.\n"
  id: String!

  "The Market owner address for which TBV is being calculated.\n"
  owner: String!

  "The quote Token for which TBV is being calculated.\n"
  token: String!

  "The network name, as used by Graph Protocol.\n**NOTE** This may not be the same as the name as used by wallets.\nAs such, we use the chainId field to identify networks in our frontend.\n"
  network: String!

  "The numeric chain ID on which the contracts are deployed.\n"
  chainId: BigInt!

  "The amount of the quote token received across the owner's markets.\n"
  tbv: BigDecimal!

  "A list of BondPurchase records in which the owner has received the quote token.\n"
  bondPurchases(skip: Int = 0, first: Int = 100, orderBy: BondPurchase_orderBy, orderDirection: OrderDirection, where: BondPurchase_filter): [BondPurchase!]
}

input OwnerTokenTbv_filter {
  id: String
  id_not: String
  id_gt: String
  id_lt: String
  id_gte: String
  id_lte: String
  id_in: [String!]
  id_not_in: [String!]
  id_contains: String
  id_contains_nocase: String
  id_not_contains: String
  id_not_contains_nocase: String
  id_starts_with: String
  id_starts_with_nocase: String
  id_not_starts_with: String
  id_not_starts_with_nocase: String
  id_ends_with: String
  id_ends_with_nocase: String
  id_not_ends_with: String
  id_not_ends_with_nocase: String
  owner: String
  owner_not: String
  owner_gt: String
  owner_lt: String
  owner_gte: String
  owner_lte: String
  owner_in: [String!]
  owner_not_in: [String!]
  owner_contains: String
  owner_contains_nocase: String
  owner_not_contains: String
  owner_not_contains_nocase: String
  owner_starts_with: String
  owner_starts_with_nocase: String
  owner_not_starts_with: String
  owner_not_starts_with_nocase: String
  owner_ends_with: String
  owner_ends_with_nocase: String
  owner_not_ends_with: String
  owner_not_ends_with_nocase: String
  token: String
  token_not: String
  token_gt: String
  token_lt: String
  token_gte: String
  token_lte: String
  token_in: [String!]
  token_not_in: [String!]
  token_contains: String
  token_contains_nocase: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  network: String
  network_not: String
  network_gt: String
  network_lt: String
  network_gte: String
  network_lte: String
  network_in: [String!]
  network_not_in: [String!]
  network_contains: String
  network_contains_nocase: String
  network_not_contains: String
  network_not_contains_nocase: String
  network_starts_with: String
  network_starts_with_nocase: String
  network_not_starts_with: String
  network_not_starts_with_nocase: String
  network_ends_with: String
  network_ends_with_nocase: String
  network_not_ends_with: String
  network_not_ends_with_nocase: String
  chainId: BigInt
  chainId_not: BigInt
  chainId_gt: BigInt
  chainId_lt: BigInt
  chainId_gte: BigInt
  chainId_lte: BigInt
  chainId_in: [BigInt!]
  chainId_not_in: [BigInt!]
  tbv: BigDecimal
  tbv_not: BigDecimal
  tbv_gt: BigDecimal
  tbv_lt: BigDecimal
  tbv_gte: BigDecimal
  tbv_lte: BigDecimal
  tbv_in: [BigDecimal!]
  tbv_not_in: [BigDecimal!]
  bondPurchases_: BondPurchase_filter

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [OwnerTokenTbv_filter]
  or: [OwnerTokenTbv_filter]
}

enum OwnerTokenTbv_orderBy {
  id
  owner
  token
  network
  chainId
  tbv
  bondPurchases
}

"The Pair entity stores references to the Tokens which make up a Uniswap-V2 or similar LP Pair.\n"
type Pair {
  "The address of the LP pair.\n**NOTE** for consistency, this should probably be updated to append the chainId, as Token and BalancerWeightedPool do.\n"
  id: String!

  "A reference to the Token record for the LP pair's token0.\n"
  token0: Token!

  "A reference to the Token record for the LP pair's token1.\n"
  token1: Token!
}

input Pair_filter {
  id: String
  id_not: String
  id_gt: String
  id_lt: String
  id_gte: String
  id_lte: String
  id_in: [String!]
  id_not_in: [String!]
  id_contains: String
  id_contains_nocase: String
  id_not_contains: String
  id_not_contains_nocase: String
  id_starts_with: String
  id_starts_with_nocase: String
  id_not_starts_with: String
  id_not_starts_with_nocase: String
  id_ends_with: String
  id_ends_with_nocase: String
  id_not_ends_with: String
  id_not_ends_with_nocase: String
  token0: String
  token0_not: String
  token0_gt: String
  token0_lt: String
  token0_gte: String
  token0_lte: String
  token0_in: [String!]
  token0_not_in: [String!]
  token0_contains: String
  token0_contains_nocase: String
  token0_not_contains: String
  token0_not_contains_nocase: String
  token0_starts_with: String
  token0_starts_with_nocase: String
  token0_not_starts_with: String
  token0_not_starts_with_nocase: String
  token0_ends_with: String
  token0_ends_with_nocase: String
  token0_not_ends_with: String
  token0_not_ends_with_nocase: String
  token0_: Token_filter
  token1: String
  token1_not: String
  token1_gt: String
  token1_lt: String
  token1_gte: String
  token1_lte: String
  token1_in: [String!]
  token1_not_in: [String!]
  token1_contains: String
  token1_contains_nocase: String
  token1_not_contains: String
  token1_not_contains_nocase: String
  token1_starts_with: String
  token1_starts_with_nocase: String
  token1_not_starts_with: String
  token1_not_starts_with_nocase: String
  token1_ends_with: String
  token1_ends_with_nocase: String
  token1_not_ends_with: String
  token1_not_ends_with_nocase: String
  token1_: Token_filter

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [Pair_filter]
  or: [Pair_filter]
}

enum Pair_orderBy {
  id
  token0
  token0__id
  token0__network
  token0__chainId
  token0__address
  token0__decimals
  token0__symbol
  token0__name
  token0__typeName
  token0__usedAsPayout
  token0__usedAsQuote
  token0__totalPayoutAmount
  token0__purchaseCount
  token1
  token1__id
  token1__network
  token1__chainId
  token1__address
  token1__decimals
  token1__symbol
  token1__name
  token1__typeName
  token1__usedAsPayout
  token1__usedAsQuote
  token1__totalPayoutAmount
  token1__purchaseCount
}

type PayoutToken {
  id: String!
}

"The PayoutTokenTbv entity tracks the total of each quote token received in exchange for the given payout token.\n"
type PayoutTokenTbv {
  "Unique ID for the PayoutTokenTbv entity, in the format:\n[chainId]_[payout token address]__[quote token id]\n**NOTE** the Token ID also appends the chain ID before the token address, so the chain ID will appear once at the start of the OwnerTokenTbv ID and once in the quote token subsection of the ID.\n"
  id: String!

  "The payout Token address for which TBV is being calculated.\n"
  payoutToken: Token!

  "The quote Token for which TBV is being calculated.\n"
  quoteToken: Token!

  "The network name, as used by Graph Protocol.\n**NOTE** This may not be the same as the name as used by wallets.\nAs such, we use the chainId field to identify networks in our frontend.\n"
  network: String!

  "The numeric chain ID on which the contracts are deployed.\n"
  chainId: BigInt!

  "The amount of the quote token received across the owner's markets.\n"
  tbv: BigDecimal!

  "A list of BondPurchase records in which the owner has received the quote token.\n"
  bondPurchases(skip: Int = 0, first: Int = 100, orderBy: BondPurchase_orderBy, orderDirection: OrderDirection, where: BondPurchase_filter): [BondPurchase!]
}

input PayoutTokenTbv_filter {
  id: String
  id_not: String
  id_gt: String
  id_lt: String
  id_gte: String
  id_lte: String
  id_in: [String!]
  id_not_in: [String!]
  id_contains: String
  id_contains_nocase: String
  id_not_contains: String
  id_not_contains_nocase: String
  id_starts_with: String
  id_starts_with_nocase: String
  id_not_starts_with: String
  id_not_starts_with_nocase: String
  id_ends_with: String
  id_ends_with_nocase: String
  id_not_ends_with: String
  id_not_ends_with_nocase: String
  payoutToken: String
  payoutToken_not: String
  payoutToken_gt: String
  payoutToken_lt: String
  payoutToken_gte: String
  payoutToken_lte: String
  payoutToken_in: [String!]
  payoutToken_not_in: [String!]
  payoutToken_contains: String
  payoutToken_contains_nocase: String
  payoutToken_not_contains: String
  payoutToken_not_contains_nocase: String
  payoutToken_starts_with: String
  payoutToken_starts_with_nocase: String
  payoutToken_not_starts_with: String
  payoutToken_not_starts_with_nocase: String
  payoutToken_ends_with: String
  payoutToken_ends_with_nocase: String
  payoutToken_not_ends_with: String
  payoutToken_not_ends_with_nocase: String
  payoutToken_: Token_filter
  quoteToken: String
  quoteToken_not: String
  quoteToken_gt: String
  quoteToken_lt: String
  quoteToken_gte: String
  quoteToken_lte: String
  quoteToken_in: [String!]
  quoteToken_not_in: [String!]
  quoteToken_contains: String
  quoteToken_contains_nocase: String
  quoteToken_not_contains: String
  quoteToken_not_contains_nocase: String
  quoteToken_starts_with: String
  quoteToken_starts_with_nocase: String
  quoteToken_not_starts_with: String
  quoteToken_not_starts_with_nocase: String
  quoteToken_ends_with: String
  quoteToken_ends_with_nocase: String
  quoteToken_not_ends_with: String
  quoteToken_not_ends_with_nocase: String
  quoteToken_: Token_filter
  network: String
  network_not: String
  network_gt: String
  network_lt: String
  network_gte: String
  network_lte: String
  network_in: [String!]
  network_not_in: [String!]
  network_contains: String
  network_contains_nocase: String
  network_not_contains: String
  network_not_contains_nocase: String
  network_starts_with: String
  network_starts_with_nocase: String
  network_not_starts_with: String
  network_not_starts_with_nocase: String
  network_ends_with: String
  network_ends_with_nocase: String
  network_not_ends_with: String
  network_not_ends_with_nocase: String
  chainId: BigInt
  chainId_not: BigInt
  chainId_gt: BigInt
  chainId_lt: BigInt
  chainId_gte: BigInt
  chainId_lte: BigInt
  chainId_in: [BigInt!]
  chainId_not_in: [BigInt!]
  tbv: BigDecimal
  tbv_not: BigDecimal
  tbv_gt: BigDecimal
  tbv_lt: BigDecimal
  tbv_gte: BigDecimal
  tbv_lte: BigDecimal
  tbv_in: [BigDecimal!]
  tbv_not_in: [BigDecimal!]
  bondPurchases_: BondPurchase_filter

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [PayoutTokenTbv_filter]
  or: [PayoutTokenTbv_filter]
}

enum PayoutTokenTbv_orderBy {
  id
  payoutToken
  payoutToken__id
  payoutToken__network
  payoutToken__chainId
  payoutToken__address
  payoutToken__decimals
  payoutToken__symbol
  payoutToken__name
  payoutToken__typeName
  payoutToken__usedAsPayout
  payoutToken__usedAsQuote
  payoutToken__totalPayoutAmount
  payoutToken__purchaseCount
  quoteToken
  quoteToken__id
  quoteToken__network
  quoteToken__chainId
  quoteToken__address
  quoteToken__decimals
  quoteToken__symbol
  quoteToken__name
  quoteToken__typeName
  quoteToken__usedAsPayout
  quoteToken__usedAsQuote
  quoteToken__totalPayoutAmount
  quoteToken__purchaseCount
  network
  chainId
  tbv
  bondPurchases
}

input PayoutToken_filter {
  id: String
  id_not: String
  id_gt: String
  id_lt: String
  id_gte: String
  id_lte: String
  id_in: [String!]
  id_not_in: [String!]
  id_contains: String
  id_contains_nocase: String
  id_not_contains: String
  id_not_contains_nocase: String
  id_starts_with: String
  id_starts_with_nocase: String
  id_not_starts_with: String
  id_not_starts_with_nocase: String
  id_ends_with: String
  id_ends_with_nocase: String
  id_not_ends_with: String
  id_not_ends_with_nocase: String

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [PayoutToken_filter]
  or: [PayoutToken_filter]
}

enum PayoutToken_orderBy {
  id
}

"Workaround due to no simple entity count being available.\n"
type PurchaseCount {
  "There should only be one PurchaseCount entry, with id \"purchase-count\".\n"
  id: String!

  "The total number of bond purchases across all markets on this chain.\n"
  count: BigInt!
}

input PurchaseCount_filter {
  id: String
  id_not: String
  id_gt: String
  id_lt: String
  id_gte: String
  id_lte: String
  id_in: [String!]
  id_not_in: [String!]
  id_contains: String
  id_contains_nocase: String
  id_not_contains: String
  id_not_contains_nocase: String
  id_starts_with: String
  id_starts_with_nocase: String
  id_not_starts_with: String
  id_not_starts_with_nocase: String
  id_ends_with: String
  id_ends_with_nocase: String
  id_not_ends_with: String
  id_not_ends_with_nocase: String
  count: BigInt
  count_not: BigInt
  count_gt: BigInt
  count_lt: BigInt
  count_gte: BigInt
  count_lte: BigInt
  count_in: [BigInt!]
  count_not_in: [BigInt!]

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [PurchaseCount_filter]
  or: [PurchaseCount_filter]
}

enum PurchaseCount_orderBy {
  id
  count
}

type Query {
  ownerBalance(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): OwnerBalance
  ownerBalances(
    skip: Int = 0
    first: Int = 100
    orderBy: OwnerBalance_orderBy
    orderDirection: OrderDirection
    where: OwnerBalance_filter

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [OwnerBalance!]!
  uniqueBonder(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): UniqueBonder
  uniqueBonders(
    skip: Int = 0
    first: Int = 100
    orderBy: UniqueBonder_orderBy
    orderDirection: OrderDirection
    where: UniqueBonder_filter

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [UniqueBonder!]!
  uniqueBonderCount(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): UniqueBonderCount
  uniqueBonderCounts(
    skip: Int = 0
    first: Int = 100
    orderBy: UniqueBonderCount_orderBy
    orderDirection: OrderDirection
    where: UniqueBonderCount_filter

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [UniqueBonderCount!]!
  uniqueTokenBonder(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): UniqueTokenBonder
  uniqueTokenBonders(
    skip: Int = 0
    first: Int = 100
    orderBy: UniqueTokenBonder_orderBy
    orderDirection: OrderDirection
    where: UniqueTokenBonder_filter

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [UniqueTokenBonder!]!
  uniqueTokenBonderCount(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): UniqueTokenBonderCount
  uniqueTokenBonderCounts(
    skip: Int = 0
    first: Int = 100
    orderBy: UniqueTokenBonderCount_orderBy
    orderDirection: OrderDirection
    where: UniqueTokenBonderCount_filter

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [UniqueTokenBonderCount!]!
  bondToken(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): BondToken
  bondTokens(
    skip: Int = 0
    first: Int = 100
    orderBy: BondToken_orderBy
    orderDirection: OrderDirection
    where: BondToken_filter

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [BondToken!]!
  ownerTokenTbv(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): OwnerTokenTbv
  ownerTokenTbvs(
    skip: Int = 0
    first: Int = 100
    orderBy: OwnerTokenTbv_orderBy
    orderDirection: OrderDirection
    where: OwnerTokenTbv_filter

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [OwnerTokenTbv!]!
  payoutTokenTbv(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PayoutTokenTbv
  payoutTokenTbvs(
    skip: Int = 0
    first: Int = 100
    orderBy: PayoutTokenTbv_orderBy
    orderDirection: OrderDirection
    where: PayoutTokenTbv_filter

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [PayoutTokenTbv!]!
  bondPurchase(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): BondPurchase
  bondPurchases(
    skip: Int = 0
    first: Int = 100
    orderBy: BondPurchase_orderBy
    orderDirection: OrderDirection
    where: BondPurchase_filter

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [BondPurchase!]!
  token(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Token
  tokens(
    skip: Int = 0
    first: Int = 100
    orderBy: Token_orderBy
    orderDirection: OrderDirection
    where: Token_filter

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Token!]!
  market(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Market
  markets(
    skip: Int = 0
    first: Int = 100
    orderBy: Market_orderBy
    orderDirection: OrderDirection
    where: Market_filter

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Market!]!
  pair(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Pair
  pairs(
    skip: Int = 0
    first: Int = 100
    orderBy: Pair_orderBy
    orderDirection: OrderDirection
    where: Pair_filter

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Pair!]!
  balancerWeightedPool(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): BalancerWeightedPool
  balancerWeightedPools(
    skip: Int = 0
    first: Int = 100
    orderBy: BalancerWeightedPool_orderBy
    orderDirection: OrderDirection
    where: BalancerWeightedPool_filter

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [BalancerWeightedPool!]!
  tune(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Tune
  tunes(
    skip: Int = 0
    first: Int = 100
    orderBy: Tune_orderBy
    orderDirection: OrderDirection
    where: Tune_filter

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Tune!]!
  purchaseCount(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PurchaseCount
  purchaseCounts(
    skip: Int = 0
    first: Int = 100
    orderBy: PurchaseCount_orderBy
    orderDirection: OrderDirection
    where: PurchaseCount_filter

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [PurchaseCount!]!
  marketOwnerCount(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): MarketOwnerCount
  marketOwnerCounts(
    skip: Int = 0
    first: Int = 100
    orderBy: MarketOwnerCount_orderBy
    orderDirection: OrderDirection
    where: MarketOwnerCount_filter

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [MarketOwnerCount!]!
  payoutToken(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PayoutToken
  payoutTokens(
    skip: Int = 0
    first: Int = 100
    orderBy: PayoutToken_orderBy
    orderDirection: OrderDirection
    where: PayoutToken_filter

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [PayoutToken!]!
  quoteToken(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): QuoteToken
  quoteTokens(
    skip: Int = 0
    first: Int = 100
    orderBy: QuoteToken_orderBy
    orderDirection: OrderDirection
    where: QuoteToken_filter

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [QuoteToken!]!

  """Access to subgraph metadata"""
  _meta(block: Block_height): _Meta_
}

type QuoteToken {
  id: String!
}

input QuoteToken_filter {
  id: String
  id_not: String
  id_gt: String
  id_lt: String
  id_gte: String
  id_lte: String
  id_in: [String!]
  id_not_in: [String!]
  id_contains: String
  id_contains_nocase: String
  id_not_contains: String
  id_not_contains_nocase: String
  id_starts_with: String
  id_starts_with_nocase: String
  id_not_starts_with: String
  id_not_starts_with_nocase: String
  id_ends_with: String
  id_ends_with_nocase: String
  id_not_ends_with: String
  id_not_ends_with_nocase: String

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [QuoteToken_filter]
  or: [QuoteToken_filter]
}

enum QuoteToken_orderBy {
  id
}

type Subscription {
  ownerBalance(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): OwnerBalance
  ownerBalances(
    skip: Int = 0
    first: Int = 100
    orderBy: OwnerBalance_orderBy
    orderDirection: OrderDirection
    where: OwnerBalance_filter

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [OwnerBalance!]!
  uniqueBonder(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): UniqueBonder
  uniqueBonders(
    skip: Int = 0
    first: Int = 100
    orderBy: UniqueBonder_orderBy
    orderDirection: OrderDirection
    where: UniqueBonder_filter

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [UniqueBonder!]!
  uniqueBonderCount(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): UniqueBonderCount
  uniqueBonderCounts(
    skip: Int = 0
    first: Int = 100
    orderBy: UniqueBonderCount_orderBy
    orderDirection: OrderDirection
    where: UniqueBonderCount_filter

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [UniqueBonderCount!]!
  uniqueTokenBonder(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): UniqueTokenBonder
  uniqueTokenBonders(
    skip: Int = 0
    first: Int = 100
    orderBy: UniqueTokenBonder_orderBy
    orderDirection: OrderDirection
    where: UniqueTokenBonder_filter

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [UniqueTokenBonder!]!
  uniqueTokenBonderCount(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): UniqueTokenBonderCount
  uniqueTokenBonderCounts(
    skip: Int = 0
    first: Int = 100
    orderBy: UniqueTokenBonderCount_orderBy
    orderDirection: OrderDirection
    where: UniqueTokenBonderCount_filter

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [UniqueTokenBonderCount!]!
  bondToken(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): BondToken
  bondTokens(
    skip: Int = 0
    first: Int = 100
    orderBy: BondToken_orderBy
    orderDirection: OrderDirection
    where: BondToken_filter

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [BondToken!]!
  ownerTokenTbv(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): OwnerTokenTbv
  ownerTokenTbvs(
    skip: Int = 0
    first: Int = 100
    orderBy: OwnerTokenTbv_orderBy
    orderDirection: OrderDirection
    where: OwnerTokenTbv_filter

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [OwnerTokenTbv!]!
  payoutTokenTbv(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PayoutTokenTbv
  payoutTokenTbvs(
    skip: Int = 0
    first: Int = 100
    orderBy: PayoutTokenTbv_orderBy
    orderDirection: OrderDirection
    where: PayoutTokenTbv_filter

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [PayoutTokenTbv!]!
  bondPurchase(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): BondPurchase
  bondPurchases(
    skip: Int = 0
    first: Int = 100
    orderBy: BondPurchase_orderBy
    orderDirection: OrderDirection
    where: BondPurchase_filter

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [BondPurchase!]!
  token(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Token
  tokens(
    skip: Int = 0
    first: Int = 100
    orderBy: Token_orderBy
    orderDirection: OrderDirection
    where: Token_filter

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Token!]!
  market(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Market
  markets(
    skip: Int = 0
    first: Int = 100
    orderBy: Market_orderBy
    orderDirection: OrderDirection
    where: Market_filter

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Market!]!
  pair(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Pair
  pairs(
    skip: Int = 0
    first: Int = 100
    orderBy: Pair_orderBy
    orderDirection: OrderDirection
    where: Pair_filter

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Pair!]!
  balancerWeightedPool(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): BalancerWeightedPool
  balancerWeightedPools(
    skip: Int = 0
    first: Int = 100
    orderBy: BalancerWeightedPool_orderBy
    orderDirection: OrderDirection
    where: BalancerWeightedPool_filter

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [BalancerWeightedPool!]!
  tune(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Tune
  tunes(
    skip: Int = 0
    first: Int = 100
    orderBy: Tune_orderBy
    orderDirection: OrderDirection
    where: Tune_filter

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Tune!]!
  purchaseCount(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PurchaseCount
  purchaseCounts(
    skip: Int = 0
    first: Int = 100
    orderBy: PurchaseCount_orderBy
    orderDirection: OrderDirection
    where: PurchaseCount_filter

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [PurchaseCount!]!
  marketOwnerCount(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): MarketOwnerCount
  marketOwnerCounts(
    skip: Int = 0
    first: Int = 100
    orderBy: MarketOwnerCount_orderBy
    orderDirection: OrderDirection
    where: MarketOwnerCount_filter

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [MarketOwnerCount!]!
  payoutToken(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PayoutToken
  payoutTokens(
    skip: Int = 0
    first: Int = 100
    orderBy: PayoutToken_orderBy
    orderDirection: OrderDirection
    where: PayoutToken_filter

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [PayoutToken!]!
  quoteToken(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): QuoteToken
  quoteTokens(
    skip: Int = 0
    first: Int = 100
    orderBy: QuoteToken_orderBy
    orderDirection: OrderDirection
    where: QuoteToken_filter

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [QuoteToken!]!

  """Access to subgraph metadata"""
  _meta(block: Block_height): _Meta_
}

"A string representation of microseconds UNIX timestamp (16 digits)\n"
scalar Timestamp

"The Token entity tracks all payout and quote tokens, including LP pairs, Balancer Pools etc and their constituent tokens.\n"
type Token {
  "Unique ID for the Token entity, in the format:\n[chainId]_[token address]\n"
  id: String!

  "The network name, as used by Graph Protocol.\n**NOTE** This may not be the same as the name as used by wallets.\nAs such, we use the chainId field to identify networks in our frontend.\n"
  network: String!

  "The numeric chain ID on which the contracts are deployed.\n"
  chainId: BigInt!

  "The address of the Token.\n"
  address: String!

  "The number of decimals for the Token.\n"
  decimals: BigInt!

  "The Token symbol.\n"
  symbol: String!

  "The Token name.\n"
  name: String!

  "The smart contract (as opposed to token) name - e.g. \"ERC20\", \"SLP\", \"BalancerWeightedPool\".\n"
  typeName: String!

  "A reference to the Pair record, if the Token is a Uniswap-V2 (or compatible) LP token, null if it is not.\n"
  lpPair: Pair

  "A reference to the BalancerWeightedPool record, if the Token is a BalancerWeightedPool, or null if it is not.\n"
  balancerWeightedPool: BalancerWeightedPool

  "Whether the Token has been used as a Payout Token for any Markets\n"
  usedAsPayout: Boolean!

  "Whether the Token has been used as a Quote Token for any Markets\n"
  usedAsQuote: Boolean!

  "The amount of the this token paid out across the owner's markets.\n"
  totalPayoutAmount: BigDecimal!

  "The total number of times this Token has been purchased on this chain.\n"
  purchaseCount: BigInt!

  "A list of PayoutTokenTbv for this Token.\n"
  payoutTokenTbvs(skip: Int = 0, first: Int = 100, orderBy: PayoutTokenTbv_orderBy, orderDirection: OrderDirection, where: PayoutTokenTbv_filter): [PayoutTokenTbv!]

  "The UniqueTokenBonderCount for this Token\n"
  uniqueBonders: UniqueTokenBonderCount

  "Markets for this Token\n"
  markets(skip: Int = 0, first: Int = 100, orderBy: Market_orderBy, orderDirection: OrderDirection, where: Market_filter): [Market!]
}

input Token_filter {
  id: String
  id_not: String
  id_gt: String
  id_lt: String
  id_gte: String
  id_lte: String
  id_in: [String!]
  id_not_in: [String!]
  id_contains: String
  id_contains_nocase: String
  id_not_contains: String
  id_not_contains_nocase: String
  id_starts_with: String
  id_starts_with_nocase: String
  id_not_starts_with: String
  id_not_starts_with_nocase: String
  id_ends_with: String
  id_ends_with_nocase: String
  id_not_ends_with: String
  id_not_ends_with_nocase: String
  network: String
  network_not: String
  network_gt: String
  network_lt: String
  network_gte: String
  network_lte: String
  network_in: [String!]
  network_not_in: [String!]
  network_contains: String
  network_contains_nocase: String
  network_not_contains: String
  network_not_contains_nocase: String
  network_starts_with: String
  network_starts_with_nocase: String
  network_not_starts_with: String
  network_not_starts_with_nocase: String
  network_ends_with: String
  network_ends_with_nocase: String
  network_not_ends_with: String
  network_not_ends_with_nocase: String
  chainId: BigInt
  chainId_not: BigInt
  chainId_gt: BigInt
  chainId_lt: BigInt
  chainId_gte: BigInt
  chainId_lte: BigInt
  chainId_in: [BigInt!]
  chainId_not_in: [BigInt!]
  address: String
  address_not: String
  address_gt: String
  address_lt: String
  address_gte: String
  address_lte: String
  address_in: [String!]
  address_not_in: [String!]
  address_contains: String
  address_contains_nocase: String
  address_not_contains: String
  address_not_contains_nocase: String
  address_starts_with: String
  address_starts_with_nocase: String
  address_not_starts_with: String
  address_not_starts_with_nocase: String
  address_ends_with: String
  address_ends_with_nocase: String
  address_not_ends_with: String
  address_not_ends_with_nocase: String
  decimals: BigInt
  decimals_not: BigInt
  decimals_gt: BigInt
  decimals_lt: BigInt
  decimals_gte: BigInt
  decimals_lte: BigInt
  decimals_in: [BigInt!]
  decimals_not_in: [BigInt!]
  symbol: String
  symbol_not: String
  symbol_gt: String
  symbol_lt: String
  symbol_gte: String
  symbol_lte: String
  symbol_in: [String!]
  symbol_not_in: [String!]
  symbol_contains: String
  symbol_contains_nocase: String
  symbol_not_contains: String
  symbol_not_contains_nocase: String
  symbol_starts_with: String
  symbol_starts_with_nocase: String
  symbol_not_starts_with: String
  symbol_not_starts_with_nocase: String
  symbol_ends_with: String
  symbol_ends_with_nocase: String
  symbol_not_ends_with: String
  symbol_not_ends_with_nocase: String
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  typeName: String
  typeName_not: String
  typeName_gt: String
  typeName_lt: String
  typeName_gte: String
  typeName_lte: String
  typeName_in: [String!]
  typeName_not_in: [String!]
  typeName_contains: String
  typeName_contains_nocase: String
  typeName_not_contains: String
  typeName_not_contains_nocase: String
  typeName_starts_with: String
  typeName_starts_with_nocase: String
  typeName_not_starts_with: String
  typeName_not_starts_with_nocase: String
  typeName_ends_with: String
  typeName_ends_with_nocase: String
  typeName_not_ends_with: String
  typeName_not_ends_with_nocase: String
  lpPair: String
  lpPair_not: String
  lpPair_gt: String
  lpPair_lt: String
  lpPair_gte: String
  lpPair_lte: String
  lpPair_in: [String!]
  lpPair_not_in: [String!]
  lpPair_contains: String
  lpPair_contains_nocase: String
  lpPair_not_contains: String
  lpPair_not_contains_nocase: String
  lpPair_starts_with: String
  lpPair_starts_with_nocase: String
  lpPair_not_starts_with: String
  lpPair_not_starts_with_nocase: String
  lpPair_ends_with: String
  lpPair_ends_with_nocase: String
  lpPair_not_ends_with: String
  lpPair_not_ends_with_nocase: String
  lpPair_: Pair_filter
  balancerWeightedPool: String
  balancerWeightedPool_not: String
  balancerWeightedPool_gt: String
  balancerWeightedPool_lt: String
  balancerWeightedPool_gte: String
  balancerWeightedPool_lte: String
  balancerWeightedPool_in: [String!]
  balancerWeightedPool_not_in: [String!]
  balancerWeightedPool_contains: String
  balancerWeightedPool_contains_nocase: String
  balancerWeightedPool_not_contains: String
  balancerWeightedPool_not_contains_nocase: String
  balancerWeightedPool_starts_with: String
  balancerWeightedPool_starts_with_nocase: String
  balancerWeightedPool_not_starts_with: String
  balancerWeightedPool_not_starts_with_nocase: String
  balancerWeightedPool_ends_with: String
  balancerWeightedPool_ends_with_nocase: String
  balancerWeightedPool_not_ends_with: String
  balancerWeightedPool_not_ends_with_nocase: String
  balancerWeightedPool_: BalancerWeightedPool_filter
  usedAsPayout: Boolean
  usedAsPayout_not: Boolean
  usedAsPayout_in: [Boolean!]
  usedAsPayout_not_in: [Boolean!]
  usedAsQuote: Boolean
  usedAsQuote_not: Boolean
  usedAsQuote_in: [Boolean!]
  usedAsQuote_not_in: [Boolean!]
  totalPayoutAmount: BigDecimal
  totalPayoutAmount_not: BigDecimal
  totalPayoutAmount_gt: BigDecimal
  totalPayoutAmount_lt: BigDecimal
  totalPayoutAmount_gte: BigDecimal
  totalPayoutAmount_lte: BigDecimal
  totalPayoutAmount_in: [BigDecimal!]
  totalPayoutAmount_not_in: [BigDecimal!]
  purchaseCount: BigInt
  purchaseCount_not: BigInt
  purchaseCount_gt: BigInt
  purchaseCount_lt: BigInt
  purchaseCount_gte: BigInt
  purchaseCount_lte: BigInt
  purchaseCount_in: [BigInt!]
  purchaseCount_not_in: [BigInt!]
  payoutTokenTbvs_: PayoutTokenTbv_filter
  uniqueBonders_: UniqueTokenBonderCount_filter
  markets_: Market_filter

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [Token_filter]
  or: [Token_filter]
}

enum Token_orderBy {
  id
  network
  chainId
  address
  decimals
  symbol
  name
  typeName
  lpPair
  lpPair__id
  balancerWeightedPool
  balancerWeightedPool__id
  balancerWeightedPool__vaultAddress
  balancerWeightedPool__poolId
  usedAsPayout
  usedAsQuote
  totalPayoutAmount
  purchaseCount
  payoutTokenTbvs
  uniqueBonders
  uniqueBonders__id
  uniqueBonders__count
  markets
}

"The Tune entity tracks Market tuning events.\n"
type Tune {
  "The ID of the Market to which the event relates.\n"
  id: String!

  "A reference to the related Market record.\n"
  market: Market!

  "The pre-tuning value of the control variable.\n"
  oldControlVariable: BigInt!

  "The post-tuning value of the control variable.\n"
  newControlVariable: BigInt!

  "The difference between the old and new control variables.\noldControlVariable - newControlVariable\n"
  deltaTime: BigInt!

  "The timestamp at which the tuning event occurred.\n"
  timestamp: BigInt!
}

input Tune_filter {
  id: String
  id_not: String
  id_gt: String
  id_lt: String
  id_gte: String
  id_lte: String
  id_in: [String!]
  id_not_in: [String!]
  id_contains: String
  id_contains_nocase: String
  id_not_contains: String
  id_not_contains_nocase: String
  id_starts_with: String
  id_starts_with_nocase: String
  id_not_starts_with: String
  id_not_starts_with_nocase: String
  id_ends_with: String
  id_ends_with_nocase: String
  id_not_ends_with: String
  id_not_ends_with_nocase: String
  market: String
  market_not: String
  market_gt: String
  market_lt: String
  market_gte: String
  market_lte: String
  market_in: [String!]
  market_not_in: [String!]
  market_contains: String
  market_contains_nocase: String
  market_not_contains: String
  market_not_contains_nocase: String
  market_starts_with: String
  market_starts_with_nocase: String
  market_not_starts_with: String
  market_not_starts_with_nocase: String
  market_ends_with: String
  market_ends_with_nocase: String
  market_not_ends_with: String
  market_not_ends_with_nocase: String
  market_: Market_filter
  oldControlVariable: BigInt
  oldControlVariable_not: BigInt
  oldControlVariable_gt: BigInt
  oldControlVariable_lt: BigInt
  oldControlVariable_gte: BigInt
  oldControlVariable_lte: BigInt
  oldControlVariable_in: [BigInt!]
  oldControlVariable_not_in: [BigInt!]
  newControlVariable: BigInt
  newControlVariable_not: BigInt
  newControlVariable_gt: BigInt
  newControlVariable_lt: BigInt
  newControlVariable_gte: BigInt
  newControlVariable_lte: BigInt
  newControlVariable_in: [BigInt!]
  newControlVariable_not_in: [BigInt!]
  deltaTime: BigInt
  deltaTime_not: BigInt
  deltaTime_gt: BigInt
  deltaTime_lt: BigInt
  deltaTime_gte: BigInt
  deltaTime_lte: BigInt
  deltaTime_in: [BigInt!]
  deltaTime_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [Tune_filter]
  or: [Tune_filter]
}

enum Tune_orderBy {
  id
  market
  market__id
  market__name
  market__type
  market__network
  market__chainId
  market__auctioneer
  market__teller
  market__marketId
  market__owner
  market__vesting
  market__start
  market__conclusion
  market__vestingType
  market__isInstantSwap
  market__hasClosed
  market__totalBondedAmount
  market__totalPayoutAmount
  market__creationBlockTimestamp
  market__callbackAddress
  market__capacity
  market__capacityInQuote
  market__minPrice
  market__price
  market__scale
  market__averageBondPrice
  market__bondsIssued
  oldControlVariable
  newControlVariable
  deltaTime
  timestamp
}

"A UniqueBonder record is created for each unique combination of chain, market owner, bond purchaser.\n"
type UniqueBonder {
  "Unique ID for the UniqueBonder entity, in the format:\n[chainId]_[Market owner address]__[bond purchaser address]\n"
  id: String!
}

"Workaround due to no simple entity count being available.\n"
type UniqueBonderCount {
  "There should be one UniqueBonderCount entry per market owner, with owner address as id.\n"
  id: String!

  "The total number of unique bonders for this token on this chain.\n"
  count: BigInt!
}

input UniqueBonderCount_filter {
  id: String
  id_not: String
  id_gt: String
  id_lt: String
  id_gte: String
  id_lte: String
  id_in: [String!]
  id_not_in: [String!]
  id_contains: String
  id_contains_nocase: String
  id_not_contains: String
  id_not_contains_nocase: String
  id_starts_with: String
  id_starts_with_nocase: String
  id_not_starts_with: String
  id_not_starts_with_nocase: String
  id_ends_with: String
  id_ends_with_nocase: String
  id_not_ends_with: String
  id_not_ends_with_nocase: String
  count: BigInt
  count_not: BigInt
  count_gt: BigInt
  count_lt: BigInt
  count_gte: BigInt
  count_lte: BigInt
  count_in: [BigInt!]
  count_not_in: [BigInt!]

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [UniqueBonderCount_filter]
  or: [UniqueBonderCount_filter]
}

enum UniqueBonderCount_orderBy {
  id
  count
}

input UniqueBonder_filter {
  id: String
  id_not: String
  id_gt: String
  id_lt: String
  id_gte: String
  id_lte: String
  id_in: [String!]
  id_not_in: [String!]
  id_contains: String
  id_contains_nocase: String
  id_not_contains: String
  id_not_contains_nocase: String
  id_starts_with: String
  id_starts_with_nocase: String
  id_not_starts_with: String
  id_not_starts_with_nocase: String
  id_ends_with: String
  id_ends_with_nocase: String
  id_not_ends_with: String
  id_not_ends_with_nocase: String

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [UniqueBonder_filter]
  or: [UniqueBonder_filter]
}

enum UniqueBonder_orderBy {
  id
}

"A UniqueTokenBonder record is created for each unique combination of chain, payout token address, bond purchaser.\n"
type UniqueTokenBonder {
  "Unique ID for the UniqueTokenBonder entity, in the format:\n[chainId]_[payout token address]__[bond purchaser address]\n"
  id: String!
}

"Workaround due to no simple entity count being available.\n"
type UniqueTokenBonderCount {
  "There should be one UniqueTokenBonderCount entry per token, with token address as id.\n"
  id: String!

  "The token for which bonders are being counted.\n"
  token: Token!

  "The total number of unique bonders for this token on this chain.\n"
  count: BigInt!
}

input UniqueTokenBonderCount_filter {
  id: String
  id_not: String
  id_gt: String
  id_lt: String
  id_gte: String
  id_lte: String
  id_in: [String!]
  id_not_in: [String!]
  id_contains: String
  id_contains_nocase: String
  id_not_contains: String
  id_not_contains_nocase: String
  id_starts_with: String
  id_starts_with_nocase: String
  id_not_starts_with: String
  id_not_starts_with_nocase: String
  id_ends_with: String
  id_ends_with_nocase: String
  id_not_ends_with: String
  id_not_ends_with_nocase: String
  token: String
  token_not: String
  token_gt: String
  token_lt: String
  token_gte: String
  token_lte: String
  token_in: [String!]
  token_not_in: [String!]
  token_contains: String
  token_contains_nocase: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  token_: Token_filter
  count: BigInt
  count_not: BigInt
  count_gt: BigInt
  count_lt: BigInt
  count_gte: BigInt
  count_lte: BigInt
  count_in: [BigInt!]
  count_not_in: [BigInt!]

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [UniqueTokenBonderCount_filter]
  or: [UniqueTokenBonderCount_filter]
}

enum UniqueTokenBonderCount_orderBy {
  id
  token
  token__id
  token__network
  token__chainId
  token__address
  token__decimals
  token__symbol
  token__name
  token__typeName
  token__usedAsPayout
  token__usedAsQuote
  token__totalPayoutAmount
  token__purchaseCount
  count
}

input UniqueTokenBonder_filter {
  id: String
  id_not: String
  id_gt: String
  id_lt: String
  id_gte: String
  id_lte: String
  id_in: [String!]
  id_not_in: [String!]
  id_contains: String
  id_contains_nocase: String
  id_not_contains: String
  id_not_contains_nocase: String
  id_starts_with: String
  id_starts_with_nocase: String
  id_not_starts_with: String
  id_not_starts_with_nocase: String
  id_ends_with: String
  id_ends_with_nocase: String
  id_not_ends_with: String
  id_not_ends_with_nocase: String

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [UniqueTokenBonder_filter]
  or: [UniqueTokenBonder_filter]
}

enum UniqueTokenBonder_orderBy {
  id
}

type _Block_ {
  """The hash of the block"""
  hash: Bytes

  """The block number"""
  number: Int!

  """Integer representation of the timestamp stored in blocks for the chain"""
  timestamp: Int

  """The hash of the parent block"""
  parentHash: Bytes
}

"""The type for the top-level _meta field"""
type _Meta_ {
  "Information about a specific subgraph block. The hash of the block\nwill be null if the _meta field has a block constraint that asks for\na block number. It will be filled if the _meta field has no block constraint\nand therefore asks for the latest  block\n"
  block: _Block_!

  """The deployment ID"""
  deployment: String!

  """If `true`, the subgraph encountered indexing errors at some past block"""
  hasIndexingErrors: Boolean!
}

enum _SubgraphErrorPolicy_ {
  """Data will be returned even if the subgraph has indexing errors"""
  allow

  """
  If the subgraph has indexing errors, data will be omitted. The default.
  """
  deny
}